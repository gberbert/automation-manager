const express = require('express');
const cors = require('cors');
const cron = require('node-cron');
const axios = require('axios');
const admin = require('firebase-admin');
const { generatePost } = require('./utils/gemini');
const { publishPost, uploadImageOnly } = require('./utils/linkedin'); 
require('dotenv').config();

const app = express();
app.use(cors());
app.use(express.json());

// Firebase Init
let serviceAccount;
if (process.env.FIREBASE_SERVICE_ACCOUNT) {
    try { serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT); } catch (e) { console.error(e); }
} else {
    try { serviceAccount = require('./serviceAccountKey.json'); } catch (e) { console.warn("No local key"); }
}

if (serviceAccount) {
    admin.initializeApp({ credential: admin.credential.cert(serviceAccount) });
    console.log("âœ… Firebase Admin initialized");
}

const db = admin.firestore();

// --- HELPER: PEGAR HORA ATUAL HH:MM ---
function getCurrentTime() {
    const now = new Date();
    // Ajuste o fuso horÃ¡rio conforme necessÃ¡rio. Vercel roda em UTC.
    // Aqui estou convertendo para BrasÃ­lia (UTC-3) para bater com a UX do usuÃ¡rio BR.
    // Se o usuÃ¡rio estiver em outro lugar, o ideal seria salvar o timezone dele.
    // Vou usar UTC-3 fixo como exemplo padrÃ£o.
    const options = { timeZone: 'America/Sao_Paulo', hour: '2-digit', minute: '2-digit', hour12: false };
    return new Intl.DateTimeFormat('pt-BR', options).format(now);
}

// --- LÃ“GICA 1: CRIAÃ‡ÃƒO AUTOMÃTICA ---
async function checkAndCreatePosts(settings) {
    if (!settings.scheduler?.creation?.enabled) return;

    const nowTime = getCurrentTime();
    console.log(`â° [Creation Check] Hora atual (BR): ${nowTime}`);

    const creationConfig = settings.scheduler.creation;

    // Helper interno para gerar
    const triggerGeneration = async (platform, count) => {
        console.log(`ðŸš€ Iniciando criaÃ§Ã£o automÃ¡tica para ${platform} (${count} posts)...`);
        for (let i = 0; i < count; i++) {
            try {
                // Simula configuraÃ§Ãµes especÃ­ficas se necessÃ¡rio, ou usa o global
                // Aqui estou passando o settings global, o generatePost decide o tÃ³pico
                const result = await generatePost(settings); 
                if (result) {
                    await db.collection('posts').add({
                        ...result,
                        platform: platform, // Marca qual rede Ã©
                        status: 'pending',
                        createdAt: admin.firestore.FieldValue.serverTimestamp(),
                        autoGenerated: true
                    });
                    console.log(`âœ… Post auto-gerado para ${platform} (${i+1}/${count})`);
                }
            } catch (e) {
                console.error(`âŒ Erro gerando post auto para ${platform}:`, e.message);
            }
        }
    };

    // Checa LinkedIn
    if (creationConfig.linkedin?.enabled && creationConfig.linkedin.time === nowTime) {
        await triggerGeneration('linkedin', creationConfig.linkedin.count || 1);
    }

    // Checa Instagram
    if (creationConfig.instagram?.enabled && creationConfig.instagram.time === nowTime) {
        await triggerGeneration('instagram', creationConfig.instagram.count || 1);
    }
}

// --- LÃ“GICA 2: PUBLICAÃ‡ÃƒO AUTOMÃTICA ---
async function checkAndPublishPosts(settings) {
    if (!settings.scheduler?.publishing?.enabled) return { published: 0, message: "Scheduler Disabled" };

    const nowTime = getCurrentTime();
    console.log(`â° [Publish Check] Hora atual (BR): ${nowTime}`);

    const publishTimes = settings.scheduler.publishing.times || [];
    
    // Se a hora atual NÃƒO for uma das horas configuradas (OpÃ§Ã£o 1, 2, 3), sai.
    if (!publishTimes.includes(nowTime)) {
        return { published: 0, message: "Not a publishing time slot" };
    }

    // SE FOR A HORA: Pega o post APROVADO mais antigo
    const approvedPostsSnapshot = await db.collection('posts')
        .where('status', '==', 'approved')
        .orderBy('createdAt', 'asc') // FIFO: Primeiro que entrou, primeiro que sai
        .limit(1) // Publica apenas 1 por slot de horÃ¡rio
        .get();

    if (approvedPostsSnapshot.empty) {
        console.log("ðŸ“­ Nenhum post aprovado na fila para publicar agora.");
        return { published: 0, message: "Queue empty" };
    }

    const doc = approvedPostsSnapshot.docs[0];
    const post = doc.data();

    console.log(`ðŸ“¤ Hora do Show! Publicando post ${doc.id} no slot das ${nowTime}...`);

    // Tenta publicar (LinkedIn Ã© o padrÃ£o por enquanto, ou baseado no campo 'platform')
    // Nota: Se for Instagram, precisaria chamar a funÃ§Ã£o de postar no Insta (ainda nÃ£o implementada no backend)
    // Por seguranÃ§a, sÃ³ publica se for LinkedIn ou sem plataforma definida
    if (!post.platform || post.platform === 'linkedin') {
        
        // Tenta Upload Imagem primeiro (se tiver)
        let assetUrn = null;
        if (post.imageUrl && post.imageUrl.includes('pollinations')) { // SÃ³ faz upload nativo se for pollination
             try {
                 assetUrn = await uploadImageOnly(post.imageUrl, settings);
             } catch(e) {
                 console.warn("Falha upload imagem background, indo sem asset");
             }
        }

        const success = await publishPost(post, settings, assetUrn);

        if (success) {
            await db.collection('posts').doc(doc.id).update({
                status: 'published',
                publishedAt: admin.firestore.FieldValue.serverTimestamp()
            });
            console.log(`âœ… Post ${doc.id} publicado com sucesso!`);
            return { published: 1, id: doc.id };
        } else {
            // LOOP PROTECTION: Marca como 'failed' e NÃƒO TENTA MAIS AUTOMATICAMENTE
            console.error(`âŒ Falha ao publicar ${doc.id}. Marcando como 'failed' para seguranÃ§a.`);
            await db.collection('posts').doc(doc.id).update({
                status: 'failed',
                errorLog: 'Falha automÃ¡tica no slot agendado. Tente manual.',
                lastAttempt: admin.firestore.FieldValue.serverTimestamp()
            });
            return { published: 0, error: "Failed" };
        }
    } else {
        console.log(`âš ï¸ Post ${doc.id} Ã© de ${post.platform}, pulando publicaÃ§Ã£o automÃ¡tica (ainda nÃ£o suportado).`);
        return { published: 0, message: "Platform not supported auto" };
    }
}

// --- SCHEDULER MASTER ---
async function runScheduler() {
    try {
        const settingsDoc = await db.collection('settings').doc('global').get();
        if (!settingsDoc.exists) return;
        const settings = settingsDoc.data();

        // Roda as checagens em paralelo
        await Promise.all([
            checkAndCreatePosts(settings),
            checkAndPublishPosts(settings)
        ]);

    } catch (error) {
        console.error("Master Scheduler Error:", error);
    }
}

// Cron roda a cada minuto
cron.schedule('* * * * *', async () => {
    await runScheduler();
});

// Rota para forÃ§ar o cron via Vercel (opcional)
app.get('/api/cron', async (req, res) => {
    await runScheduler();
    res.json({ status: 'Scheduler Executed Check Logs' });
});

// ... (Resto das rotas do index.js mantidas iguais: upload-media, publish-now, generate-content, auth, etc.)
// Certifique-se de manter as rotas que definimos antes abaixo desta linha!

// Rota Upload Media
app.post('/api/upload-media', async (req, res) => {
    // ... (CÃ³digo igual ao anterior) ...
    try {
        const { imageUrl } = req.body;
        if (!imageUrl) return res.status(400).json({ error: "No image URL provided" });
        const settingsDoc = await db.collection('settings').doc('global').get();
        if (!settingsDoc.exists) return res.status(400).json({ error: "Settings not found" });
        const assetUrn = await uploadImageOnly(imageUrl, settingsDoc.data());
        res.json({ success: true, assetUrn });
    } catch (error) { res.status(500).json({ error: error.message }); }
});

// Rota Publish Now
app.post('/api/publish-now/:postId', async (req, res) => {
    // ... (CÃ³digo igual ao anterior) ...
    try {
        const { postId } = req.params;
        const { mediaAsset } = req.body; 
        const settingsDoc = await db.collection('settings').doc('global').get();
        const postDoc = await db.collection('posts').doc(postId).get();
        if (!postDoc.exists) return res.status(404).json({ error: "Post not found" });
        const success = await publishPost(postDoc.data(), settingsDoc.data(), mediaAsset);
        if (success) {
            await db.collection('posts').doc(postId).update({ status: 'published', publishedAt: admin.firestore.FieldValue.serverTimestamp() });
            res.json({ success: true });
        } else { res.status(500).json({ error: "Failed to publish" }); }
    } catch (error) { res.status(500).json({ error: error.message }); }
});

// Rota Generate
app.post('/api/generate-content', async (req, res) => {
    try {
        const settingsDoc = await db.collection('settings').doc('global').get();
        if (!settingsDoc.exists) return res.status(400).json({ error: "No settings" });
        const result = await generatePost(settingsDoc.data());
        if (result) res.json({ success: true, post: result });
        else res.status(500).json({ error: "Generation failed" });
    } catch (e) { res.status(500).json({ error: e.message }); }
});

// Rota Auth LinkedIn
app.get('/auth/linkedin/callback', async (req, res) => {
    const { code } = req.query;
    if (!code) return res.status(400).send('No code');
    try {
        const settingsDoc = await db.collection('settings').doc('global').get();
        const settings = settingsDoc.data() || {};
        const tokenResponse = await axios.post('https://www.linkedin.com/oauth/v2/accessToken', null, {
            params: {
                grant_type: 'authorization_code',
                code,
                client_id: settings.linkedinClientId || process.env.LINKEDIN_CLIENT_ID,
                client_secret: settings.linkedinClientSecret || process.env.LINKEDIN_CLIENT_SECRET,
                redirect_uri: settings.linkedinRedirectUri || 'http://localhost:3000/auth/linkedin/callback'
            },
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
        });
        await db.collection('settings').doc('global').set({ linkedinAccessToken: tokenResponse.data.access_token }, { merge: true });
        res.send('<html><body><h1>âœ… LinkedIn Connected!</h1><script>setTimeout(()=>window.close(), 2000)</script></body></html>');
    } catch (error) { res.status(500).send(`Error: ${error.message}`); }
});

const PORT = process.env.PORT || 3000;
if (process.env.NODE_ENV !== 'production') {
    app.listen(PORT, () => console.log(`ðŸš€ Server on ${PORT}`));
}

module.exports = app;