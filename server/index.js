const express = require('express');
const cors = require('cors');
const cron = require('node-cron');
const axios = require('axios');
const admin = require('firebase-admin');
const { generatePost } = require('./utils/gemini');
const { publishPost, uploadImageOnly } = require('./utils/linkedin'); 
require('dotenv').config();

const app = express();
app.use(cors());
app.use(express.json());

// Firebase Init
let serviceAccount;
if (process.env.FIREBASE_SERVICE_ACCOUNT) {
    try { serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT); } catch (e) { console.error(e); }
} else {
    try { serviceAccount = require('./serviceAccountKey.json'); } catch (e) { console.warn("No local key"); }
}

if (serviceAccount) {
    admin.initializeApp({ credential: admin.credential.cert(serviceAccount) });
    console.log("âœ… Firebase Admin initialized");
}

const db = admin.firestore();

// --- LOGGER DO SISTEMA ---
async function logSystem(type, message, details = null) {
    try {
        // Limpa logs muito antigos para nÃ£o explodir o banco (mantÃ©m Ãºltimos 100)
        // (Opcional, implementaÃ§Ã£o futura)
        
        await db.collection('system_logs').add({
            type, // 'info', 'success', 'error', 'check'
            message,
            details: details ? (typeof details === 'object' ? JSON.stringify(details) : String(details)) : null,
            timestamp: admin.firestore.FieldValue.serverTimestamp()
        });
        console.log(`[${type.toUpperCase()}] ${message}`);
    } catch (e) {
        console.error("Logger falhou:", e);
    }
}

// --- HELPER: HORA BR ---
function getCurrentTime() {
    const now = new Date();
    const options = { timeZone: 'America/Sao_Paulo', hour: '2-digit', minute: '2-digit', hour12: false };
    return new Intl.DateTimeFormat('pt-BR', options).format(now);
}

// --- CRIAÃ‡ÃƒO ---
async function checkAndCreatePosts(settings) {
    if (!settings.scheduler?.creation?.enabled) {
        // await logSystem('info', 'CriaÃ§Ã£o desativada.'); // Descomente para debug intenso
        return;
    }

    const nowTime = getCurrentTime();
    await logSystem('check', `Checando criaÃ§Ã£o. Hora Servidor (BR): ${nowTime}`);

    const creationConfig = settings.scheduler.creation;

    const triggerGeneration = async (platform, count) => {
        await logSystem('info', `Iniciando criaÃ§Ã£o para ${platform}. Meta: ${count}`);
        for (let i = 0; i < count; i++) {
            try {
                const result = await generatePost(settings); 
                if (result) {
                    await db.collection('posts').add({
                        ...result,
                        platform: platform,
                        status: 'pending',
                        createdAt: admin.firestore.FieldValue.serverTimestamp(),
                        autoGenerated: true
                    });
                    await logSystem('success', `Post criado (${platform})`, `TÃ³pico: ${result.topic}`);
                }
            } catch (e) {
                await logSystem('error', `Erro ao criar post (${platform})`, e.message);
            }
        }
    };

    if (creationConfig.linkedin?.enabled && creationConfig.linkedin.time === nowTime) {
        await triggerGeneration('linkedin', creationConfig.linkedin.count || 1);
    }
    if (creationConfig.instagram?.enabled && creationConfig.instagram.time === nowTime) {
        await triggerGeneration('instagram', creationConfig.instagram.count || 1);
    }
}

// --- PUBLICAÃ‡ÃƒO ---
async function checkAndPublishPosts(settings) {
    if (!settings.scheduler?.publishing?.enabled) return;

    const nowTime = getCurrentTime();
    // await logSystem('check', `Checando publicaÃ§Ã£o. Hora: ${nowTime}`);

    let slots = settings.scheduler.publishing.slots;
    if (!slots && settings.scheduler.publishing.times) {
        slots = settings.scheduler.publishing.times.map(t => ({ time: t, count: 1, enabled: true }));
    }

    const activeSlot = slots?.find(s => s.time === nowTime && s.enabled === true);

    if (!activeSlot) return;

    const count = activeSlot.count || 1;
    await logSystem('info', `Slot de publicaÃ§Ã£o encontrado!`, `Hora: ${nowTime}, Meta: ${count} posts.`);

    for (let i = 0; i < count; i++) {
        const approvedPostsSnapshot = await db.collection('posts')
            .where('status', '==', 'approved')
            .orderBy('createdAt', 'asc')
            .limit(1)
            .get();

        if (approvedPostsSnapshot.empty) {
            await logSystem('info', 'Fila de aprovados vazia.');
            break;
        }

        const doc = approvedPostsSnapshot.docs[0];
        const post = doc.data();

        if (!post.platform || post.platform === 'linkedin') {
            let assetUrn = null;
            if (post.imageUrl && post.imageUrl.includes('pollinations')) {
                 try { 
                     assetUrn = await uploadImageOnly(post.imageUrl, settings); 
                 } catch(e) { 
                     await logSystem('error', 'Falha upload imagem background', e.message); 
                 }
            }

            const success = await publishPost(post, settings, assetUrn);

            if (success) {
                await db.collection('posts').doc(doc.id).update({
                    status: 'published',
                    publishedAt: admin.firestore.FieldValue.serverTimestamp()
                });
                await logSystem('success', `Post publicado! ID: ${doc.id}`);
            } else {
                await db.collection('posts').doc(doc.id).update({
                    status: 'failed',
                    errorLog: 'Falha no slot automÃ¡tico.',
                    lastAttempt: admin.firestore.FieldValue.serverTimestamp()
                });
                await logSystem('error', `Falha ao publicar post ${doc.id}`, 'Marcado como failed.');
            }
        } else {
            await logSystem('info', `Post ${doc.id} Ã© de ${post.platform} (sem suporte auto ainda).`);
        }
    }
}

async function runScheduler() {
    try {
        const settingsDoc = await db.collection('settings').doc('global').get();
        if (!settingsDoc.exists) return;
        const settings = settingsDoc.data();

        await Promise.all([
            checkAndCreatePosts(settings),
            checkAndPublishPosts(settings)
        ]);
    } catch (error) {
        console.error("Master Scheduler Error:", error);
    }
}

cron.schedule('* * * * *', async () => {
    await runScheduler();
});

app.get('/api/cron', async (req, res) => {
    await runScheduler();
    res.json({ status: 'Scheduler Executed. Check System Logs tab.' });
});

// ... (Resto das rotas mantidas iguais) ...
// (Upload, Publish, Generate, Auth - Sem alteraÃ§Ãµes necessÃ¡rias aqui)
// Apenas certifique-se de que o final do arquivo exporta o app

app.post('/api/upload-media', async (req, res) => {
    try {
        const { imageUrl } = req.body;
        if (!imageUrl) return res.status(400).json({ error: "No image URL provided" });
        const settingsDoc = await db.collection('settings').doc('global').get();
        if (!settingsDoc.exists) return res.status(400).json({ error: "Settings not found" });
        const assetUrn = await uploadImageOnly(imageUrl, settingsDoc.data());
        res.json({ success: true, assetUrn });
    } catch (error) { res.status(500).json({ error: error.message }); }
});

app.post('/api/publish-now/:postId', async (req, res) => {
    try {
        const { postId } = req.params;
        const { mediaAsset } = req.body; 
        const settingsDoc = await db.collection('settings').doc('global').get();
        const postDoc = await db.collection('posts').doc(postId).get();
        if (!postDoc.exists) return res.status(404).json({ error: "Post not found" });
        const success = await publishPost(postDoc.data(), settingsDoc.data(), mediaAsset);
        if (success) {
            await db.collection('posts').doc(postId).update({ status: 'published', publishedAt: admin.firestore.FieldValue.serverTimestamp() });
            res.json({ success: true });
        } else { res.status(500).json({ error: "Failed to publish" }); }
    } catch (error) { res.status(500).json({ error: error.message }); }
});

app.post('/api/generate-content', async (req, res) => {
    try {
        const settingsDoc = await db.collection('settings').doc('global').get();
        if (!settingsDoc.exists) return res.status(400).json({ error: "No settings" });
        const result = await generatePost(settingsDoc.data());
        if (result) res.json({ success: true, post: result });
        else res.status(500).json({ error: "Generation failed" });
    } catch (e) { res.status(500).json({ error: e.message }); }
});

app.get('/auth/linkedin/callback', async (req, res) => {
    const { code } = req.query;
    if (!code) return res.status(400).send('No code');
    try {
        const settingsDoc = await db.collection('settings').doc('global').get();
        const settings = settingsDoc.data() || {};
        const tokenResponse = await axios.post('https://www.linkedin.com/oauth/v2/accessToken', null, {
            params: {
                grant_type: 'authorization_code',
                code,
                client_id: settings.linkedinClientId || process.env.LINKEDIN_CLIENT_ID,
                client_secret: settings.linkedinClientSecret || process.env.LINKEDIN_CLIENT_SECRET,
                redirect_uri: settings.linkedinRedirectUri || 'http://localhost:3000/auth/linkedin/callback'
            },
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
        });
        await db.collection('settings').doc('global').set({ linkedinAccessToken: tokenResponse.data.access_token }, { merge: true });
        res.send('<html><body><h1>âœ… LinkedIn Connected!</h1><script>setTimeout(()=>window.close(), 2000)</script></body></html>');
    } catch (error) { res.status(500).send(`Error: ${error.message}`); }
});

const PORT = process.env.PORT || 3000;
if (process.env.NODE_ENV !== 'production') {
    app.listen(PORT, () => console.log(`ðŸš€ Server on ${PORT}`));
}

module.exports = app;